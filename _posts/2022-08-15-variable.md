# 변수(대입연산자=)
- 파이썬에서는 모든것들이 객체로 구현
- 변수에는 값이 아닌 객체의 주소를 저장


```python
a = 123
print(a, type(a))

a = str(a)
print(a, type(a))

# 변수 이름을 str같은 내장함수 이름으로 쓰면?
str = 1234
print(str, type(str))
# b = str(str) ->이렇게 내장함수를 사용하지 못하는 경우가 생긴다/ 쓰지말자
```

    123 <class 'int'>
    123 <class 'str'>
    1234 <class 'int'>
    


```python
a = 10
print(type(a))
b = "python"
c = [1, 2, 3]
a = "ststst"
print(type(a))
# 변수이름 = 변수에 저장할 값(객체,object)
# 다른 언어와 다르게 파이썬은 변수는 스택영역에 주소만 가진채 있고 저장된 값은 힙영역에 있어서 스택에서 힙을 참조하는 구조

# 파이썬은 객체 참조구조(레퍼런스)
print(a) 

# 동일 변수에 객체가 2개 이상 되면 후자만 남고 앞에거는 사라짐
```

    <class 'int'>
    <class 'str'>
    ststst
    


```python
# 다른 변수에 같은 객체
# id() 는 변수가 가진 주소를 알려준다
a = 10
b = 10
print(a, id(a)) 
print(b, id(b))

# 객체가 같기때문에 변수 a와b의 id는 같다

b = 11
print(a, id(a))
print(b, id(b)) 

# 객체가 달라지면 id도 달라진다
```

    10 1630751976016
    10 1630751976016
    10 1630751976016
    11 1630751976048
    


```python
# 리스트 사용시 변수
a = [1, 2, 3]
b = [1, 2, 3]
print(a, id(a))
print(b, id(b))

# 리스트는 객체가 같아도 id가 다르다

# a에 있는 주소값(id)를 b에다 넘겨준다.
a = [1, 2, 3]
b = a 
print(a, id(a))
print(b, id(b))

# 이렇게 하면 a리스트와 b리스트의 주소는 같아진다
```

    [1, 2, 3] 1630854337984
    [1, 2, 3] 1630854338624
    [1, 2, 3] 1630854339648
    [1, 2, 3] 1630854339648
    


```python
# 확인하는법(is)
# a가 가르키는 객체와 b가 가르키는 객체가 같은가?
print(a is b) 

# a의 객체를 바꿔보면?
a[1] = 10
print(a)
print(b)

# 둘다 바뀐다 -> 같은 주소값(id)를 쓴다는게 확인된다
```

    True
    [1, 10, 3]
    [1, 10, 3]
    

- mutable : list, dict, set
- immutable : tuple, str, int, float, bool 
    - 변경되는거처럼 보이지만 객체는 변하지않는다 참조하는게 달라질뿐


```python
# 복사
# 얕은 복사[:] - 슬라이싱
import copy
a = [1, 2, 3, [10, 20]] #리스트를 복사하면 객체주소가 다르지만 리스트 안에 리스트의 객체주소는 같다
b = a[:] #주소값(id)를 복사하는게 아니고 리스트만 복사하는거라 객체주소가 다르다
a[3][0] = 100
print(a, id(a), id(a[3]))
print(b, id(b), id(b[3]))

# copy()함수
c = [1, 2, 3, 4]
d = copy.copy(c) #위에 임포트 카피 해줘야함
print(c, id(c))
print(d, id(d))
```

    [1, 2, 3, [100, 20]] 1630854341504 1630854341696
    [1, 2, 3, [100, 20]] 1630854342208 1630854341696
    [1, 2, 3, 4] 1630854341952
    [1, 2, 3, 4] 1630854342656
    


```python
# 깊은 복사 (deepcopy)
a = [1, 2, 3, [10, 20]]
b = copy.deepcopy(a)
print(a[3], id(a), id(a[3]))
print(b[3], id(b), id(b[3]))

# 요로케 딥카피로 깊은 복사를 해버리면 리스트 안에 리스트의 객체주소도 바꿔버린다

a = [1, 2, 3, [10, 20]]
b = [1, 2, 3, [10, 20]]
print(a[3], id(a), id(a[3]))
print(b[3], id(b), id(b[3]))

# 이렇게 객체를 따로따로 정의해주는거랑 같다(리스트의 경우)

# 리스트가 아닌 그냥 num객체는 객체를 따로 정의해줘도 id값이 같다
a = 100
b = 100
print(a, id(a))
print(b, id(b))
```

    [10, 20] 1630854358656 1630854019840
    [10, 20] 1630854322176 1630854351872
    [10, 20] 1630854242432 1630854341504
    [10, 20] 1630854341696 1630854342208
    100 1630752167376
    100 1630752167376
    


```python
a = 10000
b = 10000
print(a, id(a))
print(b, id(b))

# 주피터 노트북에서는 256비트를 초과하는 int는 객체주소가 다르게 나온다
```

    10000 1630854390224
    10000 1630854389936
    


```python
# 두 변수의 값을 바꿀때
a = 3
b = 5
a, b = b, a
print(a, b)
```

    5 3
    


```python
# 변수 선언방식
a = 3
print(a)

a, b = (1, 2)
print(a, b)

a, b = 3, 5
print(a, b)

(a, b) = 1, 2
print(a, b)

[a, b] = [1, 2]
print(a, b)
```

    3
    1 2
    3 5
    1 2
    1 2
    
